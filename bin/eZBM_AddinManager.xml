<?xml version="1.0"?>
<doc>
    <assembly>
        <name>eZBM_AddinManager</name>
    </assembly>
    <members>
        <member name="T:eZBMCE.AddinManager.AddinManagerLoader">
            <summary> AddinManager插件 的窗口加载、命令执行 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.form_AddinManager.#ctor">
            <summary> 构造函数 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.form_AddinManager._nodesInfo">
            <summary> 与 TreeView 同步的节点数据 </summary>
        </member>
        <member name="P:eZBMCE.AddinManager.form_AddinManager.NodesInfo">
            <summary> 与 TreeView 同步的节点数据 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.form_AddinManager.RefreshTreeView(System.Collections.Generic.Dictionary{eZBMCE.AddinManager.AddinManagerAssembly,System.Collections.Generic.List{eZBMCE.AddinManager.IBMExCommand}})">
            <summary>
            将所有的外部命令刷新到列表控件中
            </summary>
            <param name="nodesInfo">字典中每一个程序集对应其中的多个外部命令</param>
        </member>
        <member name="T:eZBMCE.AddinManager.form_AddinManager.ExCmdCompare">
            <summary> 外部命令进行比较的方法 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.form_AddinManager.AddMethodsInOneAssembly(System.String,System.Collections.Generic.List{eZBMCE.AddinManager.IBMExCommand})">
            <summary> 将从一个 Assembly 中加载进来的所有有效的外部命令同步到 _nodesInfo 中 </summary>
            <param name="methods"></param>
        </member>
        <member name="M:eZBMCE.AddinManager.form_AddinManager.ChooseOpenDll(System.String)">
            <summary> 通过选择文件对话框选择要进行数据提取的CAD文件 </summary>
            <returns> 要进行数据提取的CAD文件的绝对路径 </returns>
        </member>
        <member name="M:eZBMCE.AddinManager.form_AddinManager.ShowExCommandDescription(System.Object,System.Windows.Forms.TreeNodeMouseClickEventArgs)">
            <summary> 提取出 TreeView中节点对应的外部命令上的描述字符 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.form_AddinManager.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.form_AddinManager.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:eZBMCE.AddinManager.form_AddinManager.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.Addins.eZConstants.eZGroupCommnad">
            <summary>
            在<see cref="!:CommandMethodAttribute"/>中设置的外部命令的 GroupName。
            </summary>
        </member>
        <member name="T:eZBMCE.AddinManager.Addins.Utils">
            <summary>
            提供一些基础性的操作工具
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.Addins.Utils.GetNullableGenericArgurment(System.Type)">
            <summary>
            返回Nullable所对应的泛型。如果不是Nullable泛型，则返回null。
            </summary>
            <param name="typeIn"></param>
            <returns></returns>
        </member>
        <member name="M:eZBMCE.AddinManager.Addins.Utils.StringHasNonEnglish(System.String)">
            <summary> 指定的字符串中是否包含有非英文字符 </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:eZBMCE.AddinManager.Addins.Utils.ChooseOpenFile(System.String,System.String,System.Boolean)">
            <summary> 选择一个或多个要打开的文件。成功选择，则返回对应文件的绝对路径，否则返回 null </summary>
            <param name="title">对话框的标题</param>
            <param name="filter"> 文件过滤规则，比如 
            “材料库(*.txt)| *.txt”、
            “Excel文件(*.xls; *.xlsx; *.xlsb)| *.xls; *.xlsx; *.xlsb”、
            “Excel工作簿(*.xlsx)|*.xlsx| Excel二进制工作簿(*.xlsb) |*.xlsb| Excel 97-2003 工作簿(*.xls)|*.xls” </param>
            <param name="multiselect"> 是否支持多选 </param>
            <returns> 成功选择，则返回对应文件的绝对路径，如果没有选择任何文件，则返回 null </returns>
        </member>
        <member name="M:eZBMCE.AddinManager.Addins.Utils.ChooseSaveFile(System.String,System.String)">
            <summary> 选择要将数据保存到哪个文件。成功选择，则返回对应文件的绝对路径，否则返回 null </summary>
            <param name="title">对话框的标题</param>
            <param name="filter"> 文件过滤规则，比如 
            “材料库(*.txt)| *.txt”、
            “Excel文件(*.xls; *.xlsx; *.xlsb)| *.xls; *.xlsx; *.xlsb”、
            “Excel工作簿(*.xlsx)|*.xlsx| Excel二进制工作簿(*.xlsb) |*.xlsb| Excel 97-2003 工作簿(*.xls)|*.xls” </param>
            <returns> 成功选择，则返回对应文件的绝对路径，否则返回 null </returns>
        </member>
        <member name="T:eZBMCE.AddinManager.AddinManagerAssembly">
            <summary> 比较两个 Assembly 是否表示同一个对象 </summary>
            <remarks>在比较的过程中，会先对GetHashCode的返回值进行比较，如果返回的HashCode是相同的，则再进行 Equals 比较；
            如果返回的HashCode值不同，则直接认为Equals为false。</remarks>  
        </member>
        <member name="T:eZBMCE.AddinManager.AssemblyComparer">
            <summary> 比较两个 Assembly 是否表示同一个对象 </summary>
            <remarks>在比较的过程中，会先对GetHashCode的返回值进行比较，如果返回的HashCode是相同的，则再进行 Equals 比较；
            如果返回的HashCode值不同，则直接认为Equals为false。</remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemblyComparer.System#Collections#Generic#IComparer{eZBMCE#AddinManager#AddinManagerAssembly}#Compare(eZBMCE.AddinManager.AddinManagerAssembly,eZBMCE.AddinManager.AddinManagerAssembly)">
            <summary>
             比较两个程序集哪个排在前面
            </summary>
            <returns></returns>
        </member>
        <member name="T:eZBMCE.AddinManager.AssemblyInfoDllManager">
            <summary> 通过Dll中的Settings来进行程序集信息的存储与提取 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemblyInfoDllManager.GetInfosFromSettings">
            <summary> 将 Settings 配置文件中的字符进行反序列化 </summary>
            <returns></returns>
            <remarks>对于CAD.NET的开发，不要在 IExtensionApplication.Initialize() 方法中执行此操作，否则即使在Initialize时可以正常序列化，
            但是在调用ExternalCommand时还是会出bug，通常的报错为：没有为该对象定义无参数的构造函数。 </remarks>
        </member>
        <member name="T:eZBMCE.AddinManager.AssemblyInfoFileManager">
            <summary> 通过 外部文本文件 来进行程序集信息的存储与提取 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemblyInfoFileManager.GetInfosFromFile">
            <summary> 将外部 二进制文件 中的字符进行反序列化 </summary>
            <remarks>对于CAD.NET的开发，不要在 IExtensionApplication.Initialize() 方法中执行此操作，否则即使在Initialize时可以正常序列化，
            但是在调用ExternalCommand时还是会出bug，通常的报错为：没有为该对象定义无参数的构造函数。 </remarks>
        </member>
        <member name="T:eZBMCE.AddinManager.AssemblyInfos">
            <summary> 将 AddinManager中的程序信与外部命令信息提取为可以进行序列化的信息 </summary>
        </member>
        <member name="P:eZBMCE.AddinManager.AssemblyInfoSettings.AssemblyInfoSerial">
            <summary> 将 AddinManager 中的程序集信息序列化后的字符 </summary>
        </member>
        <member name="T:eZBMCE.AddinManager.BinarySerializer">
            <summary>
            在.NET中，我们可以将对象序列化从而保存对象的状态到内存或者磁盘文件中，或者分布式应用程序中用于系统通信，，这样就有可能做出一个“对象数据库”了。
            一般来说，二进制序列化的效率要高，所获得的字节数最小。
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.BinarySerializer.EnCode(System.IO.Stream,System.Object)">
            <summary>
            将任意一个声明为Serializable的类或者其List等集合中的数据，以二进制的格式保存到对应的流文件中。
            </summary>
            <param name="fs">推荐使用FileStream对象。此方法中不会对Stream对象进行Close。</param>
            <param name="Data">要进行保存的可序列化对象</param>
            <remarks></remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.BinarySerializer.DeCode(System.IO.Stream)">
            <summary>
            从二进制流文件中，将其中的二进制数据反序列化为对应的类或集合对象。
            </summary>
            <param name="fs">推荐使用FileStream对象。此方法中不会对Stream对象进行Close。</param>
            <returns>此二进制流文件所对应的可序列化对象</returns>
            <remarks></remarks>
        </member>
        <member name="T:eZBMCE.AddinManager.StringSerializer">
            <summary>
            将任意一个有 Serializable标记的类以二进制转换器将类中所有数据与字符串间的相互序列化。
            即可以将类中的数据（包括数组）序列化为字符，还可以将序列化的字符反序列化为一个类。
            </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.StringSerializer.Encode64(System.Object)">
            <summary>
            Encode arbitrary .NET serialisable object
            into binary data encodes as base64 string.
            </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.StringSerializer.Decode64(System.String)">
            <summary>
            Decode arbitrary .NET serialisable object
            from binary data encoded as base64 string.
            </summary>
        </member>
        <member name="T:eZBMCE.AddinManager.StringSerializer.ZengfyLinkBinder">
            <summary>
            为了解决SerializationException，方法之一是确保此assembly放置在与aCAD.exe 或 revit.exe相同的文件夹中，
            另一个方法就是实现一个像这样的类。
            </summary>
            <remarks>
             Resolve System.Runtime.Serialization.SerializationException, Message =
            "Unable to find assembly 'StoreData, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null'."
            One solution is to ensure that assembly resides in same directory as aCAD.exe or revit.exe,
            the other is to implement a class such as this, cf.
            http://www.codeproject.com/soap/Serialization_Samples.asp
            </remarks>
        </member>
        <member name="T:eZBMCE.AddinManager.AssemLoader">
            <summary> 将程序集及其引用项加载到进程中 </summary>
            <remarks>此类是完全从 Revit AddinManager中移植过来并稍微修改的</remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemLoader.#ctor">
            <summary> 构造函数 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemLoader.LoadAddin(System.String)">
            <summary> 将程序集加载到程序中 </summary>
            <param name="filePath">程序集的文件路径</param>
            <returns></returns>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemLoader.HookAssemblyResolve">
            <summary>
            AssemblyResolve事件在.Net对程序集的解析失败时触发，返回一个Assembly对象。
            因此，我们只要在这个事件的处理程序里手动加载对应目录的dll，并把对应dll的Assembly对象返回， .Net就能正确加载对应的dll了。
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemLoader.CurrentDomain_AssemblyResolve(System.Object,System.ResolveEventArgs)">
            <summary> 在 Execute() 方法中将不能引用到的程序集进行手动加载 </summary>
            <param name="sender"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemLoader.SearchAssemblyFileInTempFolder(System.String)">
            <summary> 在临时文件夹中根据程序集名搜索对应的文件：对应于引用时 Copy Local 设置为 true 的程序集 </summary>
            <param name="assemName"></param>
            <returns></returns>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemLoader.IsRevitAPIReferenced(System.Reflection.Assembly)">
            <summary>
            检查 RevitAPI.dll 是否被引用
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="T:eZBMCE.AddinManager.AssemblySelectorForm">
            <summary> 选择程序集文件的窗口 </summary>
            <remarks>此类是完全从 Revit AddinManager中移植过来并稍微修改的</remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.AssemblySelectorForm.#ctor(System.String)">
            <summary> 构造函数 </summary>
            <param name="assemName"></param>
        </member>
        <member name="T:eZBMCE.AddinManager.eZAssemblyLoader">
            <summary>
            为了将要加载的程序集中的外部命令显示到<see cref="T:eZBMCE.AddinManager.form_AddinManager"/>窗口中，
            在加载程序集时（只是加载程序集，而不是调用程序集中的外部命令时），可能会出现“未能加载文件或程序集“Accessibility,Version=2.0.0.0，Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a”或它的某一个依赖项。系统找不到指定文件。”这种报错。
            此时要利用  AppDomain.CurrentDomain.AssemblyResolve  事件进行解决。
            </summary>
            <remarks>此类由Zengfy参照<see cref="T:eZBMCE.AddinManager.AssemLoader"/>类自行编写，即为了解决在 AutoCAD 2016 中，AddinManager Load 程序集时，总是出现
            “未能加载文件或程序集“Accessibility,Version=2.0.0.0，Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a”或它的某一个依赖项。系统找不到指定文件。”
            这种报错的问题。在AutoCAD 2014 的开发中并不需要。</remarks>
        </member>
        <member name="F:eZBMCE.AddinManager.eZAssemblyLoader._srcDir">
            <summary> 要进行加载的主程序集所在的文件夹 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.eZAssemblyLoader._srcDll">
            <summary> 要进行加载的主程序集的名称，比如 eZcad.dll </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.eZAssemblyLoader._newAssemblyAddedToAppDomain">
            <summary> 是否为当前程序域中添加了新的程序集 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.eZAssemblyLoader._appDomainAssemblies">
            <summary> 当前程序域中已经加载的程序集 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.eZAssemblyLoader.HookAssemblyResolve">
            <summary>
            AssemblyResolve事件在.Net对程序集的解析失败时触发，返回一个Assembly对象。
            因此，我们只要在这个事件的处理程序里手动加载对应目录的dll，并把对应dll的Assembly对象返回， .Net就能正确加载对应的dll了。
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.eZAssemblyLoader.CurrentDomain_AssemblyResolve(System.Object,System.ResolveEventArgs)">
            <summary> 在 Execute() 方法中将不能引用到的程序集进行手动加载 </summary>
            <param name="sender"></param>
            <param name="args"></param>
            <returns>返回的程序集即作为调用的程序集，即使返回的程序集并不是想要的那一个。</returns>
        </member>
        <member name="M:eZBMCE.AddinManager.eZAssemblyLoader.SearchAssemblyFileInDllFolders(System.String)">
            <summary> 源程序集的绝对路径 </summary>
            <param name="srcDllPath"></param>
            <param name="assemName"></param>
            <returns></returns>
        </member>
        <member name="M:eZBMCE.AddinManager.eZAssemblyLoader.LoadAddin(System.String)">
            <summary> 将程序集加载到程序中 </summary>
            <param name="filePath">程序集的文件路径</param>
            <returns></returns>
        </member>
        <member name="T:eZBMCE.AddinManager.FileUtils">
            <summary> Revit AddinManager 中用来进行文件处理的类，用来参考，并不具有通用性 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.FileUtils.AddinFolderPath">
            <summary> 所有Addin临时文件在硬盘中的文本夹 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.FileUtils.AddinDebugerTextFile">
            <summary> 所有Addin文本调试器的位置 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.FileUtils.CopyFileToFolder(System.String,System.String,System.Boolean,System.Collections.Generic.List{System.IO.FileInfo})">
            <summary>
            
            </summary>
            <param name="sourceFilePath"></param>
            <param name="destFolder"></param>
            <param name="onlyCopyRelated"></param>
            <param name="allCopiedFiles">方法结束后，此 List中包含有所有复制到的文件 </param>
            <returns></returns>
        </member>
        <member name="M:eZBMCE.AddinManager.FileUtils.GetFolderSize(System.String)">
            <summary> 返回文件夹内所有文件的总大小，单位为 MB  </summary>
            <param name="folderPath"></param>
            <returns> 文件夹内所有文件的总大小，单位为 MB </returns>
        </member>
        <member name="F:eZBMCE.AddinManager.cmd_AddinManagerLoader._addinManagerFirstLoaded">
            <summary> 整个AddinManager工具首次被加载 </summary>
        </member>
        <member name="T:eZBMCE.AddinManager.IDllActivator">
            <summary>
            用于在IExternalCommand.Execute方法中，将整个项目的所有dll加载到进程中。
            以避免出现在后面出现无法加载文件或者程序集的问题。
            此接口是专门为AddinManager在调试时设计的，在最终软件发布之前，此接口以及所有与之相关的类以及调用方法都可以删除。
            </summary>
            <remarks>在每一次调用Execute方法的开关，都可以用如下代码来将对应项目的所有引用激活。
            DllActivator.DllActivator_Projects dat = new DllActivator.DllActivator_Projects();
            dat.ActivateReferences();
            </remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.IDllActivator.ActivateReferences">
            <summary> 激活本DLL所引用的那些DLLs </summary>
        </member>
        <member name="T:eZBMCE.AddinManager.DllActivator_AddinManager">
            <summary> 用于 AddinManager 中调试 dll 时将引用的程序集加载到进程中。
            用于在IExternalCommand.Execute方法中，将整个项目的所有dll加载到进程中。
            以避免出现在后面出现无法加载文件或者程序集的问题。
            此接口是专门为AddinManager在调试时设计的，在最终软件发布之前，此接口以及所有与之相关的类以及调用方法都可以删除。
            </summary>
            <remarks>在每一次调用Execute方法的开关，都可以用如下代码来将对应项目的所有引用激活。
            DllActivator.DllActivator_Projects dat = new DllActivator.DllActivator_Projects();
            dat.ActivateReferences();
            </remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.DllActivator_AddinManager.ActivateReferences">
            <summary>
            激活本DLL所引用的那些DLLs
            </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.ExCommandExecutor.InvokeCurrentExternalCommand">
            <summary> 执行当前（即上次执行过的那个）外部命令 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.ExCommandExecutor.InvokeExternalCommand(System.String,eZBMCE.AddinManager.IBMExCommand)">
            <summary> 执行 CAD 的外部命令 </summary>
            <param name="assemblyPath">外部命令所对应的dll的绝对路径</param>
            <param name="externalCommand">此命令必须是实现了 IExternalCommand.Execute </param>
            <remarks>出于调试的即时更新的考虑，这里在每一次调试外部命令时，都对最新的dll进行重新加载。</remarks>
        </member>
        <member name="M:eZBMCE.AddinManager.ExCommandExecutor.RunActiveCommand(eZBMCE.AddinManager.IBMExCommand,System.String,System.String@)">
            <summary> 执行外部命令 </summary>
            <param name="addinItem">注意这里的 addinItem 实例是刷新前的程序集中对应的类，
            这里只能用来提取其 FullName 字符串，而不能直接用来执行， 因为虽然它确实可以执行，但是执行的是重新编译前的那个方法。</param>
            <param name="assemblyPath"></param>
            <param name="errorMsg"></param>
        </member>
        <member name="M:eZBMCE.AddinManager.ExCommandExecutor.GetDebugMessage(System.Exception)">
            <summary> 在调试阶段，为每一种报错显示对应的报错信息及出错位置。 </summary>
        </member>
        <member name="T:eZBMCE.AddinManager.ExCommandFinder">
            <summary> 将指定程序集中的 IExternalCommand 类提取出来 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.ExCommandFinder.RetriveExternalCommandsFromAssembly(System.String)">
            <summary> 将程序集文件加载到内存，并且提取出其中的 CAD 外部命令 </summary>
            <param name="assemblyPath"></param>
            <returns></returns>
        </member>
        <member name="M:eZBMCE.AddinManager.ExCommandFinder.FindExCommandMethod(System.Type)">
            <summary>
            从一个 实现了 <seealso cref="T:eZBMCE.AddinManager.IBMExCommand"/> 的命令接口 的类中搜索到对应的 外部命令
            </summary>
            <param name="implimentedType">此类必须 实现了  <seealso cref="T:eZBMCE.AddinManager.IBMExCommand"/>  的命令接口 </param>
            <returns></returns>
        </member>
        <member name="T:eZBMCE.AddinManager.EcDescriptionAttribute">
            <summary> 用来作为实现 <seealso cref="T:eZBMCE.AddinManager.IBMExCommand"/> 的类的描述 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.EcDescriptionAttribute.Description">
            <summary> 具体的描述 </summary>
        </member>
        <member name="T:eZBMCE.AddinManager.ExternalCommandResult">
            <summary> AddinManager 中， <seealso cref="T:eZBMCE.AddinManager.IBMExCommand"/> 外部命令的返回结果 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.ExternalCommandResult.Cancelled">
            <summary> 外部命令执行被手动取消，事务取消 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.ExternalCommandResult.Succeeded">
            <summary> 外部命令执行成功，提交事务 </summary>
        </member>
        <member name="F:eZBMCE.AddinManager.ExternalCommandResult.Failed">
            <summary> 外部命令执行过程中出错 </summary>
        </member>
        <member name="T:eZBMCE.AddinManager.IBMExCommand">
            <summary> 用来进行AddinManager快速调试的接口。实现此接口的类必须有一个无参数的构造函数。
            另外，推荐实现此接口的类所在程序集中也设计一个实现 IDllActivator_std 接口的类。 </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.IBMExCommand.Execute(System.String@,System.Collections.Generic.IList{Bentley.DgnPlatformNET.ElementId}@)">
            <summary> Bentley AddinManger 快速调试插件 </summary>
            <param name="errorMessage">当返回值为<see cref="F:eZBMCE.AddinManager.ExternalCommandResult.Failed"/> 或者在外部命令代码执行过程中出错时，这个属性代表给出的报错信息。</param>
            <param name="elementSet">当返回值为<see cref="F:eZBMCE.AddinManager.ExternalCommandResult.Failed"/> 或者在外部命令代码执行过程中出错时，这个属性代表与出错内容相关的任何对象。</param>
            <returns></returns>
        </member>
        <member name="T:eZBMCE.AddinManager.Keyin">
            <summary>Keyin to function mapping.</summary>
        </member>
        <member name="M:eZBMCE.AddinManager.Keyin.CmdLoadAddinManager(System.String)">
            <summary>Keyin to function mapping.
            Calls ManagedToolsExample.StartPlaceGroupedHoleTool to start place tool</summary>
            <author>BentleySystems</author>
        </member>
        <member name="T:eZBMCE.AddinManager.ZfyPlugin">
            <summary>
            Main entry point class for this addin application.
            When loading an AddIn MicroStation looks for a class
            derived from AddIn.
            </summary>
        </member>
        <member name="M:eZBMCE.AddinManager.ZfyPlugin.Run(System.String[])">
            <summary>
            Initializes the AddIn. Called by the AddIn loader after
            it has created the instance of this AddIn class
            </summary>
            <param name="commandLine"></param>
            <returns>0 on success</returns>
        </member>
        <member name="M:eZBMCE.AddinManager.ZfyPlugin.eZBMCE_ReloadEvent(Bentley.MstnPlatformNET.AddIn,Bentley.MstnPlatformNET.AddIn.ReloadEventArgs)">
            <summary>
             Handles MDL ONUNLOAD requests when the application Is being unloaded.
             </summary>
             <param name="eventArgs"></param>
        </member>
        <member name="M:eZBMCE.AddinManager.ZfyPlugin.eZBMCE_UnloadedEvent(Bentley.MstnPlatformNET.AddIn,Bentley.MstnPlatformNET.AddIn.UnloadedEventArgs)">
            <summary>
            Handles MicroStation UNLOADED event.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="M:eZBMCE.AddinManager.ZfyPlugin.OnUnloading(Bentley.MstnPlatformNET.AddIn.UnloadingEventArgs)">
            <summary>
            Handles MDL ONUNLOAD requests when the application is being unloaded.
            </summary>
            <param name="eventArgs"></param>
        </member>
        <member name="F:eZBMCE.AddinManager.ZfyPlugin._hasValidNodesInfoSaved">
            <summary> 在Addin插件卸载过程中，是否已经将AddinManager窗口中的插件路径保存在mySettings中。 </summary>
            <remarks>因为在Addin插件卸载过程中，可能会多次进入此Terminate函数</remarks>
        </member>
    </members>
</doc>
